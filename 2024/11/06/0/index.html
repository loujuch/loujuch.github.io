<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="并发编程三大特性为了确保在多线程环境下内存操作的线程安全，通常要求操作具有如下特性：  原子性：对一个或多个操作，要么全部完成执行，要么全部不完成执行，不能处于完成一半的状态。  可见性：在一个控制流完成操作后，要求其他控制流能够立即获得该操作的修改。  有序性：在一个控制流眼中，其他控制流的行为应该与其代码序一致。   三特征的破坏和保证直觉上，并发编程三大特性是机器里说应当进行保证的。然而，为">
<meta property="og:type" content="article">
<meta property="og:title" content="并发编程三大特性">
<meta property="og:url" content="http://example.com/2024/11/06/0/index.html">
<meta property="og:site_name" content="Code Bank">
<meta property="og:description" content="并发编程三大特性为了确保在多线程环境下内存操作的线程安全，通常要求操作具有如下特性：  原子性：对一个或多个操作，要么全部完成执行，要么全部不完成执行，不能处于完成一半的状态。  可见性：在一个控制流完成操作后，要求其他控制流能够立即获得该操作的修改。  有序性：在一个控制流眼中，其他控制流的行为应该与其代码序一致。   三特征的破坏和保证直觉上，并发编程三大特性是机器里说应当进行保证的。然而，为">
<meta property="og:locale">
<meta property="og:image" content="http://example.com/2024/11/06/0/0.png">
<meta property="og:image" content="http://example.com/2024/11/06/0/1.png">
<meta property="og:image" content="http://example.com/2024/11/06/0/2.png">
<meta property="og:image" content="http://example.com/2024/11/06/0/3.png">
<meta property="og:image" content="http://example.com/2024/11/06/0/4.png">
<meta property="og:image" content="http://example.com/2024/11/06/0/5.png">
<meta property="og:image" content="http://example.com/2024/11/06/0/6.png">
<meta property="og:image" content="http://example.com/2024/11/06/0/7.png">
<meta property="og:image" content="http://example.com/2024/11/06/0/8.png">
<meta property="og:image" content="http://example.com/2024/11/06/0/9.png">
<meta property="og:image" content="http://example.com/2024/11/06/0/10.png">
<meta property="article:published_time" content="2024-11-06T14:34:49.000Z">
<meta property="article:modified_time" content="2024-11-13T14:55:52.238Z">
<meta property="article:author" content="Loujuch">
<meta property="article:tag" content="并发编程">
<meta property="article:tag" content="计算机系统">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2024/11/06/0/0.png">

<link rel="canonical" href="http://example.com/2024/11/06/0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-Hans'
  };
</script>

  <title>并发编程三大特性 | Code Bank</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Code Bank</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/11/06/0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Loujuch">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Code Bank">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          并发编程三大特性
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-11-06 22:34:49" itemprop="dateCreated datePublished" datetime="2024-11-06T22:34:49+08:00">2024-11-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-11-13 22:55:52" itemprop="dateModified" datetime="2024-11-13T22:55:52+08:00">2024-11-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="并发编程三大特性"><a href="#并发编程三大特性" class="headerlink" title="并发编程三大特性"></a>并发编程三大特性</h2><p>为了确保在多线程环境下内存操作的线程安全，通常要求操作具有如下特性：</p>
<ol>
<li><p>原子性：对一个或多个操作，要么全部完成执行，要么全部不完成执行，不能处于完成一半的状态。</p>
</li>
<li><p>可见性：在一个控制流完成操作后，要求其他控制流能够立即获得该操作的修改。</p>
</li>
<li><p>有序性：在一个控制流眼中，其他控制流的行为应该与其代码序一致。</p>
</li>
</ol>
<h2 id="三特征的破坏和保证"><a href="#三特征的破坏和保证" class="headerlink" title="三特征的破坏和保证"></a>三特征的破坏和保证</h2><p>直觉上，并发编程三大特性是机器里说应当进行保证的。然而，为了加强性能，计算机内部做了许多优化，使得机器无法自动的的保证上述多线程环境下程序满足上述三项性质，这需要程序员手动对其的进行控制。</p>
<p>下面将详细叙述相关优化和对应优化带来的优势、应该优化导致无法保证的特性和程序员保存对应特性的方法控制方法。</p>
<h3 id="情况0-基础情况——单控制流独占设备"><a href="#情况0-基础情况——单控制流独占设备" class="headerlink" title="情况0: 基础情况——单控制流独占设备"></a>情况0: 基础情况——单控制流独占设备</h3><p>现在想象一个最简单的情况，在这种情况中计算机系统只允许一个控制流运行，并且直到这个控制流运行完全结束前不会被打断，也就是该控制流完全独占该机器。</p>
<p><img src="/2024/11/06/0/0.png"></p>
<p>这十分符合人类直觉，计算机系统也将保证该情况下的程序操作具有全部三个特性。因此可以将其视为判断标准，当多线程环境下控制流的执行结果与该情况相同，则为正确，否则则为错误。</p>
<blockquote>
<p>该情况其实在计算机蛮荒时期出现过，被称为单道批处理系统。</p>
<p>其可以一次性多个作业（控制流），机器将会自动的依次串行执行作业，在上一个作业执行完毕前不会执行下一个作业。</p>
</blockquote>
<h3 id="情况1-中断的出现——多控制流共享设备"><a href="#情况1-中断的出现——多控制流共享设备" class="headerlink" title="情况1: 中断的出现——多控制流共享设备"></a>情况1: 中断的出现——多控制流共享设备</h3><h4 id="优化点的引入"><a href="#优化点的引入" class="headerlink" title="优化点的引入"></a>优化点的引入</h4><p>虽然情况0很符合人类直觉，但具有如下问题：</p>
<ol>
<li><p>资源利用率低：当与慢速设备进行交互时，当前控制流需要等待交互完成，因此处理器将处于等待状态，这将导致处理器的利用率降低。</p>
</li>
<li><p>响应时间长：一个作业需要等待之前的作业完成才会开始执行，因此无法保证作业的响应时间。</p>
</li>
</ol>
<h4 id="改进措施"><a href="#改进措施" class="headerlink" title="改进措施"></a>改进措施</h4><p>随着硬件的发展，DMA、中断等技术的出现，使得计算机系统能够使得多个控制流轮流共享设备，这解决了上述的两个问题：</p>
<ol>
<li><p>当进行与慢速设备的交互或大块内存的复制等操作时，可以使用DMA机制进行数据传输，处理器则执行下一个控制流；数据传输完毕时会引发中断，通知处理器处理之前未完成的控制流。通过该方式，计算机系统极大地提高了系统的资源利用率。</p>
</li>
<li><p>为了降低作业的响应时间，计算机系统将设置时钟，使得每隔指定时间便能够产生中断。在接收到中断后，处理器将会更换处理的控制流，这使得提交的作业将在合理的时间内开始处理。</p>
</li>
</ol>
<p><img src="/2024/11/06/0/1.png"></p>
<blockquote>
<p>改进后的系统被称为多道批处理系统（只进行了优化点1）和分时系统（进行了优化点1和优化点2）。</p>
<p>这种逻辑上实现多任务、实际上进行串行执行的多任务运行方式被称为并行。</p>
<p>本次改进是由DMA和中断技术的产生而发生的：</p>
<ol>
<li><p>DMA技术：在主板上引入专门用于数据传输的DMA芯片，当需要进行大规模数据传输时，处理器能够将传输任务交给DMA芯片，从而空出宝贵的处理器时间处理其他高价值任务。</p>
</li>
<li><p>中断技术：向计算机系统引入了异步通信方式，中断信号的发送方可能为外设或处理器，接收方则为处理器。当处理器接收到中断信号时，将会暂停当前处理的程序，并执行指定的程序。</p>
</li>
</ol>
<p>在DMA和中断技术出现前，处理器只能通过轮询的方式处理数据传输和错误信号，这便是单道批处理系统出现的原因。</p>
</blockquote>
<h4 id="引入的新问题"><a href="#引入的新问题" class="headerlink" title="引入的新问题"></a>引入的新问题</h4><p>尽管上述改进措施能够提升计算机系统的性能，但控制流的并行处理方式打破了之前的串行处理假设，这直接导致了原子性的破坏。</p>
<p>具体而言，该破坏包含两个层次：</p>
<ol>
<li><p>语句级别的破坏：在高级语言中，一条语句有时对应着数条的机器语句。例如对数据的修改语句通常会涉及<code>访存-修改-写回</code>等步骤，在这些步骤执行的过程中将有可能被中断打断，使得该条语句的操作将会失去原子性。</p>
<p> 例如，如下C语言代码：</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    ++a;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 编译出的对应X64汇编语言如下（未开启编译优化并去除预处理器指令）：</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">main:</span><br><span class="line">    pushq %rbp</span><br><span class="line">    movq  %rsp, %rbp</span><br><span class="line">    movl  %edi, -4(%rbp)</span><br><span class="line">    movq  %rsi, -16(%rbp)</span><br><span class="line">    movl  a(%rip), %eax</span><br><span class="line">    addl  $1, %eax</span><br><span class="line">    movl  %eax, a(%rip)</span><br><span class="line">    movl  $0, %eax</span><br><span class="line">    popq  %rbp</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>

<p> 可以看到<code>++a;</code>语句被编译为了<code>movl  a(%rip), %eax</code>、<code>addl  $1, %eax</code>、<code>movl  %eax, a(%rip)</code>三条汇编语句，这些汇编语句在执行间可能被中断打断，因此该条C语句不具有原子性。</p>
<p> <img src="/2024/11/06/0/2.png"></p>
</li>
<li><p>逻辑级别的破坏：当一个逻辑上需要多条语句原子性的执行时，语句执行间可能会被中断打断，使得该操作失去原子性。</p>
<p> 例如，转账时逻辑上需要进行两个变量的同时修改，模拟的C语言语句如下：</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my_money += <span class="number">7827798</span>;</span><br><span class="line">other_person_money -= <span class="number">7827798</span>;</span><br></pre></td></tr></table></figure>

<p> 此时两条语句间的执行可能会被中断打断，使得其他线程获得<code>my_money</code>增加7827798但<code>other_person_money</code>不变的结果，因此这些C语句不具有原子性。</p>
<p> <img src="/2024/11/06/0/3.png"></p>
</li>
</ol>
<h4 id="问题的解决"><a href="#问题的解决" class="headerlink" title="问题的解决"></a>问题的解决</h4><p>针对该情况，计算机硬件系统给出了两个方向的解决方案：</p>
<ol>
<li><p>在需要原子性的地方暂时关闭中断，这样使得该控制流不会被换出，这在物理上保证了操作的原子性。</p>
<p> 控制流的转换依赖于中断信号的通知，通过关闭中断响应，处理器能够保证执行的操作不会被打断，保证了操作的原子性。</p>
<p> <img src="/2024/11/06/0/4.png"></p>
<p> 通常各种类型的处理器都会提供相应的关&#x2F;开中断机制，操作系统也会提供对应的封装。因为其平台相关性较强且在软件开发过程中几乎不会用上，故此处不再延申。</p>
</li>
<li><p>在每次写回时查看当前值是否被修改了，如果发生修改则重做之前的操作，这在逻辑上保证了操作的原子性。</p>
<p> 从逻辑上来说，只要各个控制流处理在写回前保证之前的处理操作的输入未被修改，就能够保证该次处理的串行性：</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="type">int</span> tmp = a;</span><br><span class="line">        <span class="type">int</span> tmpa = tmp + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(tmp == a) &#123;</span><br><span class="line">            a = tmpa;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 很明显上述代码相比起之前更为复杂且仍然线程不安全，因此处理器通常会给出CAS原子指令，该指令类似于<code>原子性</code>的执行下列操作：</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">CAS</span><span class="params">(<span class="type">int</span> V, <span class="type">int</span> A, <span class="type">int</span> B)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(V == A) &#123;</span><br><span class="line">        V = B;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 使用CAS改写后，原代码变为：</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> tmp;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        tmp = a;</span><br><span class="line">    &#125; <span class="keyword">while</span>(<span class="number">0</span> == CAS(a, tmp, tmp + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 此时，当其他控制流的操作影响了a的值时，当前控制流都能够检测出，并且根据新值重新进行处理，从逻辑上保证了操作的原子性。</p>
<p> <img src="/2024/11/06/0/5.png"></p>
</li>
</ol>
<h3 id="情况2-多个执行核心——同时运行多个控制流"><a href="#情况2-多个执行核心——同时运行多个控制流" class="headerlink" title="情况2: 多个执行核心——同时运行多个控制流"></a>情况2: 多个执行核心——同时运行多个控制流</h3><h4 id="优化点的引入-1"><a href="#优化点的引入-1" class="headerlink" title="优化点的引入"></a>优化点的引入</h4><p>在实际计算机系统中，计算的速度与时钟频率和指令完成执行所需时钟数量有关，当指令所需时钟数量一定时，时钟频率越高，计算速度越快；当时钟频率一定时，指令所需时钟数量越低，计算速度越快。</p>
<p>但受限于物理器件和指令系统，时钟频率和指令所需时钟数量方面的提升十分困难且有限，这限制了单核处理器的性能。</p>
<h4 id="改进措施-1"><a href="#改进措施-1" class="headerlink" title="改进措施"></a>改进措施</h4><p>基于当前多任务的处理方式，通过在处理器上添加多个相互独立的处理单元，计算机系统能够同时运行多个任务（控制流），这极大地提高了计算机系统的处理能力。</p>
<p>这些处理单元在计算时相互独立，但共享着同一套内存、外设等。</p>
<p><img src="/2024/11/06/0/6.png"></p>
<blockquote>
<p>这种在物理上同时执行多任务的运行方式被称为并发。</p>
<p>通常情况下，在一个支持多核并发的系统中，往往也会支持并行操作。</p>
</blockquote>
<h4 id="引入的新问题-1"><a href="#引入的新问题-1" class="headerlink" title="引入的新问题"></a>引入的新问题</h4><p>尽管上述改进措施能够提升计算机系统的性能，但并发的控制流将有可能导致访存的冲突，同时多个处理单元内将有多个寄存器组，这导致了以下问题：</p>
<ol>
<li><p>共享资源的并发访问：在多个控制流同时运行时，有可能或导致在同一时刻多个控制流同时访问同一个共享资源，这破坏了操作的原子性。</p>
<p> <img src="/2024/11/06/0/7.png"></p>
</li>
<li><p>冗余的数据副本：在多个处理单元中存在多组相互独立的寄存器组，这些寄存器组中可能会存在指向相同变量的数据。当其中一方修改相应数据时，另一方可能仍然使用之前存储在寄存器中的数据，这破坏了操作的可见性。</p>
<p> 例如，如下C语言代码：</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">wait</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">0</span> == a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">notify</span><span class="params">()</span> &#123;</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 编译出的对应X64汇编语言如下（开启O1编译优化并去除预处理器指令）：</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">_Z4waitv:</span><br><span class="line">    movl  a(%rip), %eax</span><br><span class="line">.L2:</span><br><span class="line">    testl %eax, %eax</span><br><span class="line">    je	.L2</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">_Z6notifyv:</span><br><span class="line">    movl $1, a(%rip)</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>

<p> 当一个执行流中调用<code>notify</code>修改<code>a</code>的值时，调用<code>wait</code>的线程仍然会读取寄存器中的副本，这表明其出现了可见性的破坏。</p>
</li>
</ol>
<h4 id="问题的解决-1"><a href="#问题的解决-1" class="headerlink" title="问题的解决"></a>问题的解决</h4><p>针对上述问题，计算机系统依次给出了相应的解决方案：</p>
<ol>
<li><p>针对并发访问冲突问题，计算机系统提供了总线锁进行解决。在总线锁定期间，处理单元将会在总线上发送LOCK信号，这将阻止其他处理单元通过总线访问资源。</p>
<p> 总线锁的具体实现与对应的处理器平台有关，通常情况下，当一个处理单元获得总线锁后，便独占了全部共享资源。这从硬件层面解决了操作原子性的问题。</p>
<p> <img src="/2024/11/06/0/8.png"></p>
<p> 通常情况下总线锁通过在对应汇编语言指令前添加LOCK前缀进行获取，但在部分平台中也可能会对未显示声明的语句添加总线锁。因为其平台相关性较强且在软件开发过程中几乎不会用上，故此处不再延申。</p>
</li>
<li><p>针对可见性问题，该问题在当前形态下可以在编译期进行解决，C语言提供了<code>volatile</code>关键字来保证每次对变量的访问均来自内存。</p>
<p> 例如，如下C语言代码：</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">wait</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">0</span> == a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">notify</span><span class="params">()</span> &#123;</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 编译出的对应X64汇编语言如下（开启O3编译优化并去除预处理器指令）：</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">_Z4waitv:</span><br><span class="line">.L2:</span><br><span class="line">    movl  a(%rip), %eax</span><br><span class="line">    testl %eax, %eax</span><br><span class="line">    je	.L2</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">_Z6notifyv:</span><br><span class="line">    movl $1, a(%rip)</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>

<p> 由汇编代码中可以看出，当访问对应变量时，控制流总会去访问对应的内存，这便解决了寄存器变量不更新导致的可见性问题。</p>
</li>
</ol>
<h3 id="情况3-更快的访存——单控制流下的Cache"><a href="#情况3-更快的访存——单控制流下的Cache" class="headerlink" title="情况3: 更快的访存——单控制流下的Cache"></a>情况3: 更快的访存——单控制流下的Cache</h3><h4 id="优化点的引入-2"><a href="#优化点的引入-2" class="headerlink" title="优化点的引入"></a>优化点的引入</h4><p>本情况实际上是对情况1的优化，与情况2基本无关。</p>
<p>在之前的构想中，处理器都是直接与内存进行交互的。随着技术的发展，处理器的速度不断加快，与内存的读写速度间的差异逐渐变大，如果每条指令和数据都需要进行访存操作，这将严重降低计算机性能。</p>
<p>目前使用的内存基本均由DRAM组成，在使用中其表现出了如下问题：</p>
<ol>
<li><p>DRAM基于电容机制存储数据，使得其需要定期刷新以保持内部数据，这降低了其的信息存取速度。</p>
</li>
<li><p>通常而言，内存只能一次性进行有限数量的操作（具体由通道数而定），同时CPU、GPU、DMA等都存在内存访问需求，这制约了内存的并发处理能力。</p>
</li>
</ol>
<p>这些问题都制约了内存的处理能力。</p>
<h4 id="改进措施-2"><a href="#改进措施-2" class="headerlink" title="改进措施"></a>改进措施</h4><p>在对计算机程序进行统计时会发现，计算机程序的运行具有浓厚的局部性特征，这使得将当前内存的子集放置到一个更快的物理存储结构成为提高系统性能的方案，这些用于存放内存子集数据的物理存储结构被称为Cache。</p>
<p><img src="/2024/11/06/0/9.png"></p>
<blockquote>
<p>局部性包含了时间局部性和空间局部性，其中时间局部性指在某个时间点访问的内存，在相邻的时间点更有可能被访问；空间局部性指在当某个地址空间被访问时，其相邻的地址空间更有可能被访问。</p>
<p>局部性表示了循环结构在程序运行中的重要地位，同时也因为数组结构的广泛使用、局部变量在栈上连续分布等原因而出现。</p>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> *num, <span class="type">unsigned</span> len, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123; <span class="comment">// 循环结构使得指令被反复使用</span></span><br><span class="line">       num[i] = val; <span class="comment">// 数组结构和局部变量的连续排布使得相邻存储空间被使用</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>Cache进行了如下优化，使得其相对于内存而言具有更快的速度：</p>
<ol>
<li><p>使用基于锁存器结构的SRAM组成，这种结构在物理结构上具有更快的速度。</p>
</li>
<li><p>通过缓存分区、私有缓存等方式，使得Cache具有较好的并发处理能力。</p>
</li>
<li><p>仅有CPU占用，不涉及与其他物理元件的争用。</p>
</li>
<li><p>排线上更接近CPU，数据传输延时少。</p>
</li>
</ol>
<h4 id="带Cache的内存写入"><a href="#带Cache的内存写入" class="headerlink" title="带Cache的内存写入"></a>带Cache的内存写入</h4><p>在该情况下，显然这不会导致并发三特性的破坏，但在该情况下如何进行数据写入方面仍具有一些值得讨论的问题。</p>
<p>目前，在包含Cache的计算机系统中，对数据进行写入操作有两种常用方法：</p>
<ol>
<li><p>直写法：处理器同时修改Cache和对应内存地址的数据。</p>
<p> 直写法需要处理器直接与内存进行交互，这将会降低系统的执行效率。</p>
</li>
<li><p>回写法：处理器只修改Cache的值，在对应的Cache换出时才写入对应内存。</p>
<p> 回写法减少了处理器与内存的交互，提高了执行效率。但由于回写过程的存在，使得需要更复杂的硬件，并且存在潜在的一致性问题。</p>
</li>
</ol>
<p>目前主流计算机系统普遍采用回写法作为内存修改方法，下面的全部讨论均以此为基础。</p>
<h3 id="情况4-冗余的代价——多控制流下的Cache同步"><a href="#情况4-冗余的代价——多控制流下的Cache同步" class="headerlink" title="情况4: 冗余的代价——多控制流下的Cache同步"></a>情况4: 冗余的代价——多控制流下的Cache同步</h3><h4 id="改进措施-3"><a href="#改进措施-3" class="headerlink" title="改进措施"></a>改进措施</h4><p>通过在具有Cache的单核系统中引入多核——或者说在多核系统中加入Cache，我们可以进一步的提升性能。</p>
<p>为了更好的提高Cache的并发能力，Cache将被分为3层——L1、L2和L3，其中L1离CPU最近，L3最远。这3层的情况如下：</p>
<ol>
<li><p>L3在三层中最大，内部存储内存的数据子集，通常情况下由所有CPU共享。</p>
</li>
<li><p>L2第二大，内部存储L3的数据子集，通常情况每个CPU核心都有自己的L2。</p>
</li>
<li><p>L1最小，内部存储L2的数据子集，每个CPU核心都有自己的L1，并且在L1中会分为指令缓存和数据缓存。</p>
</li>
</ol>
<p><img src="/2024/11/06/0/10.png"></p>
<h4 id="引入的新问题-2"><a href="#引入的新问题-2" class="headerlink" title="引入的新问题"></a>引入的新问题</h4><p>多处理器下Cache的引入会造成较为严重的并发问题，主要可以总结为以下两个方面：</p>
<ol>
<li><p>对共享部分（L3 Cache）的并发读写问题，这影响了操作的原子性。</p>
</li>
<li><p>各个独享部分的数据不一致问题，这影响了操作的可见性。</p>
</li>
</ol>
<h4 id="问题的解决-2"><a href="#问题的解决-2" class="headerlink" title="问题的解决"></a>问题的解决</h4><p>参照并发内存读写的解决方法，可以使用缓存锁对共享的缓存进行锁定。当访问的内存区域已经缓存在处理器的缓存行中时，处理单元对缓存中的缓存行进行锁定。在锁定期间，其它单元不能同时缓存此数据。通过该方式，能够保证缓存修改操作的原子性。</p>
<blockquote>
<p>缓存锁与总线锁十分相似，其都是通过阻塞并发处理操作的方式将目标操作序列化的。</p>
<p>在锁定范围大小方面，总线锁锁住整个处理器的总线，使得其他处理单元完全无法访问共享资源；缓存锁仅锁住目标缓存行，各处理器仍然能访问独占Cache和未被锁定的缓存行。因此，在使用缓存锁时，其他处理单元能够访问更大范围的数据，其对系统性能影响更小。</p>
<p>因此，通常系统会更希望使用缓存锁而不是总线锁，但在许多情况下，只能使用总线锁而不能使用缓存锁，例如：</p>
<ol>
<li><p>访问的内存不在Cache当中。</p>
</li>
<li><p>访问的数据跨行了，其数据不完全在同一个缓存行中。</p>
</li>
</ol>
</blockquote>
<p>缓存锁只能保证缓存修改操作的原子性，但无法处理核间Cache数据同步，因此其实际上并没有解决可见性问题。为了解决这种情况下的可见性问题，缓存一致性协议被提出。</p>
<p>缓存一致性协议用于保证多核情况下的并发操作的一致性，常见的有MSI、MESI、MOSI等。其中MESI应用较为广泛，下面将对其进行介绍</p>
<h4 id="MESI缓存一致性协议"><a href="#MESI缓存一致性协议" class="headerlink" title="MESI缓存一致性协议"></a>MESI缓存一致性协议</h4><h3 id="情况5-更极致地性能追求——指令乱序"><a href="#情况5-更极致地性能追求——指令乱序" class="headerlink" title="情况5: 更极致地性能追求——指令乱序"></a>情况5: 更极致地性能追求——指令乱序</h3>
    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" rel="tag"># 并发编程</a>
              <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/" rel="tag"># 计算机系统</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/11/04/1/" rel="prev" title="CPP原子变量">
      <i class="fa fa-chevron-left"></i> CPP原子变量
    </a></div>
      <div class="post-nav-item">
    <a href="/2024/11/11/0/" rel="next" title="Android Camera device HAL 3.6文档翻译——S6：错误管理">
      Android Camera device HAL 3.6文档翻译——S6：错误管理 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="nav-number">1.</span> <span class="nav-text">并发编程三大特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E7%89%B9%E5%BE%81%E7%9A%84%E7%A0%B4%E5%9D%8F%E5%92%8C%E4%BF%9D%E8%AF%81"><span class="nav-number">2.</span> <span class="nav-text">三特征的破坏和保证</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%83%85%E5%86%B50-%E5%9F%BA%E7%A1%80%E6%83%85%E5%86%B5%E2%80%94%E2%80%94%E5%8D%95%E6%8E%A7%E5%88%B6%E6%B5%81%E7%8B%AC%E5%8D%A0%E8%AE%BE%E5%A4%87"><span class="nav-number">2.1.</span> <span class="nav-text">情况0: 基础情况——单控制流独占设备</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%83%85%E5%86%B51-%E4%B8%AD%E6%96%AD%E7%9A%84%E5%87%BA%E7%8E%B0%E2%80%94%E2%80%94%E5%A4%9A%E6%8E%A7%E5%88%B6%E6%B5%81%E5%85%B1%E4%BA%AB%E8%AE%BE%E5%A4%87"><span class="nav-number">2.2.</span> <span class="nav-text">情况1: 中断的出现——多控制流共享设备</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E5%8C%96%E7%82%B9%E7%9A%84%E5%BC%95%E5%85%A5"><span class="nav-number">2.2.1.</span> <span class="nav-text">优化点的引入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%94%B9%E8%BF%9B%E6%8E%AA%E6%96%BD"><span class="nav-number">2.2.2.</span> <span class="nav-text">改进措施</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E5%85%A5%E7%9A%84%E6%96%B0%E9%97%AE%E9%A2%98"><span class="nav-number">2.2.3.</span> <span class="nav-text">引入的新问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3"><span class="nav-number">2.2.4.</span> <span class="nav-text">问题的解决</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%83%85%E5%86%B52-%E5%A4%9A%E4%B8%AA%E6%89%A7%E8%A1%8C%E6%A0%B8%E5%BF%83%E2%80%94%E2%80%94%E5%90%8C%E6%97%B6%E8%BF%90%E8%A1%8C%E5%A4%9A%E4%B8%AA%E6%8E%A7%E5%88%B6%E6%B5%81"><span class="nav-number">2.3.</span> <span class="nav-text">情况2: 多个执行核心——同时运行多个控制流</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E5%8C%96%E7%82%B9%E7%9A%84%E5%BC%95%E5%85%A5-1"><span class="nav-number">2.3.1.</span> <span class="nav-text">优化点的引入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%94%B9%E8%BF%9B%E6%8E%AA%E6%96%BD-1"><span class="nav-number">2.3.2.</span> <span class="nav-text">改进措施</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E5%85%A5%E7%9A%84%E6%96%B0%E9%97%AE%E9%A2%98-1"><span class="nav-number">2.3.3.</span> <span class="nav-text">引入的新问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3-1"><span class="nav-number">2.3.4.</span> <span class="nav-text">问题的解决</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%83%85%E5%86%B53-%E6%9B%B4%E5%BF%AB%E7%9A%84%E8%AE%BF%E5%AD%98%E2%80%94%E2%80%94%E5%8D%95%E6%8E%A7%E5%88%B6%E6%B5%81%E4%B8%8B%E7%9A%84Cache"><span class="nav-number">2.4.</span> <span class="nav-text">情况3: 更快的访存——单控制流下的Cache</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E5%8C%96%E7%82%B9%E7%9A%84%E5%BC%95%E5%85%A5-2"><span class="nav-number">2.4.1.</span> <span class="nav-text">优化点的引入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%94%B9%E8%BF%9B%E6%8E%AA%E6%96%BD-2"><span class="nav-number">2.4.2.</span> <span class="nav-text">改进措施</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%A6Cache%E7%9A%84%E5%86%85%E5%AD%98%E5%86%99%E5%85%A5"><span class="nav-number">2.4.3.</span> <span class="nav-text">带Cache的内存写入</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%83%85%E5%86%B54-%E5%86%97%E4%BD%99%E7%9A%84%E4%BB%A3%E4%BB%B7%E2%80%94%E2%80%94%E5%A4%9A%E6%8E%A7%E5%88%B6%E6%B5%81%E4%B8%8B%E7%9A%84Cache%E5%90%8C%E6%AD%A5"><span class="nav-number">2.5.</span> <span class="nav-text">情况4: 冗余的代价——多控制流下的Cache同步</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%94%B9%E8%BF%9B%E6%8E%AA%E6%96%BD-3"><span class="nav-number">2.5.1.</span> <span class="nav-text">改进措施</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E5%85%A5%E7%9A%84%E6%96%B0%E9%97%AE%E9%A2%98-2"><span class="nav-number">2.5.2.</span> <span class="nav-text">引入的新问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3-2"><span class="nav-number">2.5.3.</span> <span class="nav-text">问题的解决</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MESI%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE"><span class="nav-number">2.5.4.</span> <span class="nav-text">MESI缓存一致性协议</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%83%85%E5%86%B55-%E6%9B%B4%E6%9E%81%E8%87%B4%E5%9C%B0%E6%80%A7%E8%83%BD%E8%BF%BD%E6%B1%82%E2%80%94%E2%80%94%E6%8C%87%E4%BB%A4%E4%B9%B1%E5%BA%8F"><span class="nav-number">2.6.</span> <span class="nav-text">情况5: 更极致地性能追求——指令乱序</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Loujuch</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">39</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">25</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Loujuch</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
