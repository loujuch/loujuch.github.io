<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Code Bank">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Code Bank">
<meta property="og:locale">
<meta property="article:author" content="Loujuch">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-Hans'
  };
</script>

  <title>Code Bank</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Code Bank</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/11/04/0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Loujuch">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Code Bank">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/11/04/0/" class="post-title-link" itemprop="url">Bash运行某个程序一段时间后停止该程序</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2024-11-04 22:09:02 / Modified: 22:19:39" itemprop="dateCreated datePublished" datetime="2024-11-04T22:09:02+08:00">2024-11-04</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Bash未提供定时函数来设置程序终止时间，但可以通过<strong>后台运行+定时kill</strong>的方式实现相似功能，具体脚本Demo如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">./test &amp;</span><br><span class="line"></span><br><span class="line">PID=$!</span><br><span class="line"><span class="comment"># 也可以使用下述方法获取PID</span></span><br><span class="line"><span class="comment"># PID=`ps aux | grep &#x27;./test&#x27; | grep -v &#x27;grep&#x27; | awk &#x27;&#123;print $2&#125;&#x27;`</span></span><br><span class="line"></span><br><span class="line">WAIT_TIME=5</span><br><span class="line"></span><br><span class="line"><span class="built_in">sleep</span> <span class="variable">$&#123;WAIT_TIME&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">kill</span> -9 <span class="variable">$&#123;PID&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">wait</span> <span class="variable">$&#123;PID&#125;</span></span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/11/03/4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Loujuch">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Code Bank">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/11/03/4/" class="post-title-link" itemprop="url">Win10搭建GStreamer开发环境</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2024-11-03 21:58:05 / Modified: 22:14:19" itemprop="dateCreated datePublished" datetime="2024-11-03T21:58:05+08:00">2024-11-03</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="下载GStreamer"><a href="#下载GStreamer" class="headerlink" title="下载GStreamer"></a>下载GStreamer</h2><p>使用Chocolatey安装GStreamer，使用管理员权限运行powershell，运行如下命令：</p>
<figure class="highlight ps1"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">choco install <span class="literal">-yes</span> gstreamer gstreamer<span class="literal">-devel</span> gstreamer<span class="literal">-mingw</span> gstreamer<span class="literal">-mingw-devel</span></span><br></pre></td></tr></table></figure>

<h2 id="下载安装VS2022"><a href="#下载安装VS2022" class="headerlink" title="下载安装VS2022"></a>下载安装VS2022</h2><p>访问<a target="_blank" rel="noopener" href="https://visualstudio.microsoft.com/zh-hans/vs/">微软官网</a>，下载安装器进行安装。</p>
<h2 id="配置依赖"><a href="#配置依赖" class="headerlink" title="配置依赖"></a>配置依赖</h2><p>创建空项目，右键点击右侧解决方案下的项目名，在弹出的菜单中选择属性：</p>
<p><img src="/2024/11/03/4/0.png"></p>
<p><img src="/2024/11/03/4/1.png"></p>
<p>在属性页的<code>C/C++ - 常规 - 附加包含目录</code>中添加如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\gstreamer\1.0\mingw_x86_64\include\gstreamer-1.0;C:\gstreamer\1.0\mingw_x86_64\include\glib-2.0;C:\gstreamer\1.0\mingw_x86_64\include\libxml2;C:\gstreamer\1.0\mingw_x86_64\lib\glib-2.0\include;C:\gstreamer\1.0\msvc_x86_64\include\GL;C:\gstreamer\1.0\mingw_x86_64\include;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/11/03/4/2.png"></p>
<p>在属性页的<code>连接器 - 常规 - 附加库目录</code>中添加如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\gstreamer\1.0\msvc_x86_64\lib;C:\gstreamer\1.0\mingw_x86_64\lib;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/11/03/4/3.png"></p>
<p>在属性页的<code>连接器 - 输出 - 附加依赖项</code>中添加如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;gobject-2.0.lib;glib-2.0.lib;gstreamer-1.0.lib;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/11/03/4/4.png"></p>
<h2 id="编写验证程序"><a href="#编写验证程序" class="headerlink" title="编写验证程序"></a>编写验证程序</h2><p>根据GStreamer教程Demo，编写如下程序验证环境搭建情况。注意，在Windows环境下需要添加<code>main_loop</code>，否则无法打开视频播放窗口。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gst/gst.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">	<span class="built_in">gst_init</span>(&amp;argc, &amp;argv);</span><br><span class="line"></span><br><span class="line">	GstElement* pipeline = <span class="built_in">gst_parse_launch</span>(<span class="string">&quot;playbin uri=https://gstreamer.freedesktop.org/data/media/sintel_trailer-480p.webm&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">	GMainLoop* main_loop = <span class="built_in">g_main_loop_new</span>(<span class="literal">NULL</span>, FALSE);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">gst_element_set_state</span>(pipeline, GST_STATE_PLAYING);</span><br><span class="line">	<span class="built_in">g_main_loop_run</span>(main_loop);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">gst_element_set_state</span>(pipeline, GST_STATE_NULL);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">gst_object_unref</span>(pipeline);</span><br><span class="line">	<span class="built_in">g_main_loop_unref</span>(main_loop);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行后成功播放目标视频，证明环境搭建完毕。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/11/03/3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Loujuch">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Code Bank">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/11/03/3/" class="post-title-link" itemprop="url">Android Camera device HAL 3.6文档翻译——S2：启动和操作顺序</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2024-11-03 17:57:46 / Modified: 21:57:43" itemprop="dateCreated datePublished" datetime="2024-11-03T17:57:46+08:00">2024-11-03</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ol>
<li><p>框架层调用<code>camera_module_t-&gt;common.open()</code>，之后HAL返回一个<code>hardware_device_t</code>结构。</p>
<blockquote>
<p><em>Framework calls camera_module_t-&gt;common.open(), which returns a hardware_device_t structure.</em></p>
</blockquote>
</li>
<li><p>框架层检查<code>hardware_device_t-&gt;version</code>，并根据相机硬件设备的版本创建相应的处理程序。如果版本为<code>CAMERA_DEVICE_API_VERSION_3_0</code>，设备实例将会被转化为<code>camera3_device_t</code>。</p>
<blockquote>
<p><em>Framework inspects the hardware_device_t-&gt;version field, and instantiates the appropriate handler for that version of the camera hardware device. In case the version is CAMERA_DEVICE_API_VERSION_3_0, the device is cast to a camera3_device_t.</em></p>
</blockquote>
</li>
<li><p>框架层调用<code>camera3_device_t-&gt;ops-&gt;initialize()</code>并将框架层回调函数指针传入。该函数只会在<code>open()</code>函数被调用后和在ops结构的任何其他函数被调用前的时间间隔中被调用一次。</p>
<blockquote>
<p><em>Framework calls camera3_device_t-&gt;ops-&gt;initialize() with the framework callback function pointers. This will only be called this one time after open(), before any other functions in the ops structure are called.</em></p>
</blockquote>
</li>
<li><p>框架层调用<code>camera3_device_t-&gt;ops-&gt;configure_streams()</code>，将一个输入&#x2F;输出流列表传递到HAL设备中。</p>
<blockquote>
<p><em>The framework calls camera3_device_t-&gt;ops-&gt;configure_streams() with a list of input&#x2F;output streams to the HAL device.</em></p>
</blockquote>
</li>
<li><p>根据设备版本进行不同的处理</p>
<p> 版本低于或等于<code>CAMERA_DEVICE_API_VERSION_3_1</code>时，框架层分配图形缓冲区并为configure_streams中的至少一个输出流调用<code>camera3_device_t-&gt;ops-&gt;register_stream_buffers()</code>。相同的流只会被注册一次。</p>
<blockquote>
<p><em>&lt;&#x3D; CAMERA_DEVICE_API_VERSION_3_1: The framework allocates gralloc buffers and calls camera3_device_t-&gt;ops-&gt;register_stream_buffers() for at least one of the output streams listed in configure_streams. The same stream is registered only once.</em></p>
</blockquote>
<p> 版本低于或等于<code>CAMERA_DEVICE_API_VERSION_3_2</code>时，<code>camera3_device_t-&gt;ops-&gt;register_stream_buffers()</code>不会被调用，其必须为<code>NULL</code>。</p>
<blockquote>
<p><em>CAMERA_DEVICE_API_VERSION_3_2:camera3_device_t-&gt;ops-&gt;register_stream_buffers() is not called and must be NULL.</em></p>
</blockquote>
</li>
<li><p>框架层调用<code>camera3_device_t-&gt;ops-&gt;construct_default_request_settings()</code>请求一些使用用例的默认设置。这可能发生在步骤3之后的任何时间。</p>
<blockquote>
<p>The framework requests default settings for some number of use cases with calls to camera3_device_t-&gt;ops-&gt;construct_default_request_settings(). This may occur any time after step 3.</p>
</blockquote>
</li>
<li><p>框架层构造并向HAL发送第一个捕获请求。该请求携带着基于默认设置集合中的某一个默认设置的设置项，并且关联着不少于一个之前框架层完成注册的输出流。请求被<code>camera3_device_t-&gt;ops-&gt;process_capture_request()</code>方法传送到HAL。HAL将会阻塞该方法的返回，直到下一个请求将被发送。</p>
<blockquote>
<p><em>The framework constructs and sends the first capture request to the HAL, with settings based on one of the sets of default settings, and with at least one output stream, which has been registered earlier by the framework. This is sent to the HAL with camera3_device_t-&gt;ops-&gt;process_capture_request(). The HAL must block the return of this call until it is ready for the next request to be sent.</em></p>
</blockquote>
<p> 版本为<code>CAMERA_DEVICE_API_VERSION_3_2</code>或更高时，在<code>camera3_capture_request_t</code>中的<code>camera3_stream_buffer_t</code>数组中的<code>buffer_handle_t</code>可能是新的，HAL从未在任何新的请求中见过。</p>
<blockquote>
<p><em>&gt;&#x3D; CAMERA_DEVICE_API_VERSION_3_2: The buffer_handle_t provided in the camera3_stream_buffer_t array in the camera3_capture_request_t may be new and never-before-seen by the HAL on any given new request.</em></p>
</blockquote>
</li>
<li><p>框架层不断地提交请求，并调用<code>construct_default_request_settings</code>以获得其他使用用例的默认设置缓冲区。</p>
<blockquote>
<p><em>The framework continues to submit requests, and call construct_default_request_settings to get default settings buffers for other use cases.</em></p>
</blockquote>
<p> 当版本为<code>CAMERA_DEVICE_API_VERSION_3_1</code>或更低时，框架层可能会为那些还未注册的流调用register_stream_buffers()方法。</p>
<blockquote>
<p><em>&lt;&#x3D; CAMERA_DEVICE_API_VERSION_3_1: The framework may call register_stream_buffers() at this time for not-yet-registered streams.</em></p>
</blockquote>
</li>
<li><p>当捕获请求开始处理（传感器开始为捕获图像进行曝光）或当再处理请求开始被处理时，HAL将调用<code>camera3_callback_ops_t-&gt;notify()</code>，该次调用将以<code>SHUTTER</code>事件作为参数，这包括帧序号和曝光开始时间戳。对于再处理请求，时间戳必须是输入图像的曝光开始时间，在<code>process_capture_request()</code>调用时，可以从<code>camera3_capture_request_t.settings</code>的<code>android.sensor.timestamp</code>获得该时间。</p>
<blockquote>
<p><em>When the capture of a request begins (sensor starts exposing for thecapture) or processing a reprocess request begins, the HAL calls camera3_callback_ops_t-&gt;notify() with the SHUTTER event, including the frame number and the timestamp for start of exposure. For a reprocess request, the timestamp must be the start of exposure of the input image which can be looked up with android.sensor.timestamp from camera3_capture_request_t.settings when process_capture_request() is called.</em></p>
</blockquote>
<p> 当版本低于或等于<code>CAMERA_DEVICE_API_VERSION_3_1</code>时，这个通知必须在<code>process_capture_result()</code>第一次为处理该帧的调用前完成。</p>
<blockquote>
<p><em>&lt;&#x3D; CAMERA_DEVICE_API_VERSION_3_1: This notify call must be made before the first call to process_capture_result() for that frame number.</em></p>
</blockquote>
<p> 当版本高于或等于<code>CAMERA_DEVICE_API_VERSION_3_2</code>时，携带<code>SHUTTER</code>事件的<code>camera3_callback_ops_t-&gt;notify()</code>应该被尽可能早的完成，因为在接收到一个有效的曝光开始时间戳（对于再处理请求则是输入图像的开始曝光时间戳）前框架层不能将（该帧的）图形缓冲区传递到应用层。</p>
<blockquote>
<p><em>&gt;&#x3D; CAMERA_DEVICE_API_VERSION_3_2: The camera3_callback_ops_t-&gt;notify() call with the SHUTTER event should be made as early as possible since the framework will be unable to deliver gralloc buffers to the application layer (for that frame) until it has a valid timestamp for the start of exposure (or the input image’s start of exposure for a reprocess request).</em></p>
</blockquote>
<p> 部分元数据和图形缓冲区可能在<code>SHUTTER</code>时间发生前或后的任何时间返回。</p>
<blockquote>
<p><em>Both partial metadata results and the gralloc buffers may be sent to the framework at any time before or after the SHUTTER event.</em></p>
</blockquote>
</li>
<li><p>部分流水线阻塞等待一段时间后，HAL将调用<code>camera3_callback_ops_t-&gt;process_capture_result()</code>将完成的捕获结果返回框架层。结果的返回顺序将和请求提交的顺序一致。多个请求可以被同时处理，这取决于相机HAL设备的流水线深度。</p>
<p>After some pipeline delay, the HAL begins to return completed captures to the framework with camera3_callback_ops_t-&gt;process_capture_result(). These are returned in the same order as the requests were submitted. Multiple requests can be in flight at once, depending on the pipeline depth of the camera HAL device.</p>
<p>当版本高于或等于<code>CAMERA_DEVICE_API_VERSION_3_2</code>时，一旦<code>process_capture_result</code>将缓冲区作为<code>camera3_stream_buffer_t</code>数组的一部分返回且<code>release_fence</code>指定的栅栏发出信号（对于-1栅栏而言是无操作），该缓冲区的所有权将被视为转移给框架层。之后，HAL将不会保留该缓冲区，框架层能够立即清理其占用的内存。</p>
<blockquote>
<p>&gt;&#x3D; CAMERA_DEVICE_API_VERSION_3_2: Once a buffer is returned by process_capture_result as part of the camera3_stream_buffer_t array, and the fence specified by release_fence has been signaled (this is a no-op for -1 fences), the ownership of that buffer is considered to be transferred back to the framework. After that, the HAL must no longer retain that particular buffer, and the framework may clean up the memory for it immediately.</p>
</blockquote>
<p>对于同一帧，<code>process_capture_result</code>可能会被多次调用，每一次都携带一个新的不相交的元数据碎片和&#x2F;或设置图形缓冲区。框架层将合并这些分块的元数据到一个结构中。</p>
<blockquote>
<p>process_capture_result may be called multiple times for a single frame, each time with a new disjoint piece of metadata and&#x2F;or set of gralloc buffers. The framework will accumulate these partial metadata results into one result.</p>
</blockquote>
<p>特别的，只要上述规则适用于图形缓冲区（不论输入或输出），同时为第N帧和第N+1帧调用<code>process_capture_result</code>是合法的。</p>
<blockquote>
<p>In particular, it is legal for a process_capture_result to be called simultaneously for both a frame N and a frame N+1 as long as the above rule holds for gralloc buffers (both input and output).</p>
</blockquote>
</li>
<li><p>一段时间后，框架层可能停止提交新的请求，并等待现有的捕获完成（所有的缓冲区完成填充且所有的请求返回），然后再次调用<code>configure_streams()</code>。这将为一组新的输入&#x2F;输出流重置相机硬件和流水线。某些之前的流可以被复用，如果这些流的缓冲区已经被注册到HAL中了则不需要再次注册。如果至少有一个完成注册的输出流被保留，则框架层从步骤7开始（否则从步骤5开始）。</p>
<blockquote>
<p>After some time, the framework may stop submitting new requests, wait for the existing captures to complete (all buffers filled, all results returned), and then call configure_streams() again. This resets the camera hardware and pipeline for a new set of input&#x2F;output streams. Some streams may be reused from the previous configuration; if these streams’ buffers had already been registered with the HAL, they will not be registered again. The framework then continues from step 7, if at least one registered output stream remains (otherwise, step 5 is required first).</p>
</blockquote>
<p>或者框架层可能调用<code>camera3_device_t-&gt;common-&gt;close()</code>终止相机会话。这可能在没有其他任何来自框架层的请求活动的任何时候被调用，但该调用将会被阻塞直到所有正在处理的捕获完成（所有结果返回且所有缓冲区被填充）。在<code>close</code>调用返回后，不允许从HAL调用<code>camera3_callback_ops_t</code>函数。一旦<code>close()</code>的调用开始运行，框架层不能调用任何其他HAL设备函数。</p>
<blockquote>
<p>Alternatively, the framework may call camera3_device_t-&gt;common-&gt;close() to end the camera session. This may be called at any time when no other calls from the framework are active, although the call may block until all in-flight captures have completed (all results returned, all buffers filled). After the close call returns, no more calls to the camera3_callback_ops_t functions are allowed from the HAL. Once the close() call is underway, the framework may not call any other HAL device functions.</p>
</blockquote>
</li>
<li><p>当有错误或其他异步事件发生时，HAL必须调用<code>camera3_callback_ops_t-&gt;notify()</code>传递恰当的错误&#x2F;事件信息。在从一个设备范围的致命的错误通知返回后，HAL应该表现的像对其完成<code>close()</code>调用一样。同时，在调用<code>notify()</code>前HAL必须放弃或完成所有未解决的捕获，因此一旦调用<code>notify()</code>发送致命错误信息，框架层将不会从设备中接收到进一步的回调。此外，在发送错误信息的<code>notify()</code>方法返回后，<code>close()</code>应该返回<code>-ENODEV</code>或<code>NULL</code>。</p>
<blockquote>
<p>In case of an error or other asynchronous event, the HAL must call camera3_callback_ops_t-&gt;notify() with the appropriate error&#x2F;event message. After returning from a fatal device-wide error notification, the HAL should act as if close() had been called on it. However, the HAL must either cancel or complete all outstanding captures before calling notify(), so that once notify() is called with a fatal error, the framework will not receive further callbacks from the device. Methods besides close() should return -ENODEV or NULL after the notify() method returns from a fatal error message.</p>
</blockquote>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/11/03/2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Loujuch">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Code Bank">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/11/03/2/" class="post-title-link" itemprop="url">Android Camera device HAL 3.6文档翻译</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2024-11-03 17:48:26 / Modified: 17:57:30" itemprop="dateCreated datePublished" datetime="2024-11-03T17:48:26+08:00">2024-11-03</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这（Camera device HAL 3.6）是当前推荐使用的HAL版本。</p>
<blockquote>
<p><em>This is the current recommended version of the camera device HAL.</em></p>
</blockquote>
<p>其支持android.hardware.CameraAPI，但自从v3.2版本以来，android.hardware.camera2 API被设置为LIMITED或above hardware level状态。</p>
<blockquote>
<p><em>Supports the android.hardware.Camera API, and as of v3.2, the android.hardware.camera2 API as LIMITED or above hardware level.</em></p>
</blockquote>
<p>支持该版本的相机设备必须在camera_device_t.common.version和camera_info_t.device_version（由camera_module_t.get_camera_info获得）中返回CAMERA_DEVICE_API_VERSION_3_6。</p>
<blockquote>
<p><em>Camera devices that support this version of the HAL must return CAMERA_DEVICE_API_VERSION_3_6 in camera_device_t.common.version and in camera_info_t.device_version (from camera_module_t.get_camera_info).</em></p>
</blockquote>
<p>CAMERA_DEVICE_API_VERSION_3_3<br>或更高版本：包含3.3或更高版本的设备的相机模块至少需要支持2.2版本的相机模块接口（在camera_module_t.common.module_api_version中定义）。</p>
<blockquote>
<p><em>CAMERA_DEVICE_API_VERSION_3_3 and above: Camera modules that may contain version 3.3 or above devices must implement at least version 2.2 of the camera module interface (as defined by camera_module_t.common.module_api_version).</em></p>
</blockquote>
<p>CAMERA_DEVICE_API_VERSION_3_2<br>：包含3.2版本的设备的相机模块至少需要支持2.2版本的相机模块接口（如camera_module_t.common.module_api_version所定义的）。</p>
<blockquote>
<p><em>CAMERA_DEVICE_API_VERSION_3_2: Camera modules that may contain version 3.2 devices must implement at least version 2.2 of the camera module interface (as defined by camera_module_t.common.module_api_version).</em></p>
</blockquote>
<p>CAMERA_DEVICE_API_VERSION_3_1<br>或更低版本：包含3.1或更低版本的设备的相机模块至少需要支持2.0版本的相机模块接口（如camera_module_t.common.module_api_version所定义的）。</p>
<blockquote>
<p><em>&lt;&#x3D; CAMERA_DEVICE_API_VERSION_3_1: Camera modules that may contain version 3.1 (or 3.0) devices must implement at least version 2.0 of the camera module interface (as defined by camera_module_t.common.module_api_version).</em></p>
</blockquote>
<p>更多与版本相关的细节可参考camera_common.h。</p>
<blockquote>
<p><em>See camera_common.h for more versioning details.</em></p>
</blockquote>
<p>文档目录</p>
<blockquote>
<p><em>Documentation index:</em></p>
</blockquote>
<p>S1：版本历史(未开始)</p>
<blockquote>
<p><em>S1. Version history</em></p>
</blockquote>
<p>S2：启动和操作顺序</p>
<blockquote>
<p><em>S2. Startup and operation sequencing</em></p>
</blockquote>
<p>S3：操作模式(未开始)</p>
<blockquote>
<p><em>S3. Operational modes</em></p>
</blockquote>
<p>S4：3A模式和状态机(未开始)</p>
<blockquote>
<p><em>S4. 3A modes and state machines</em></p>
</blockquote>
<p>S5. 裁剪(未开始)</p>
<blockquote>
<p><em>S5. Cropping</em></p>
</blockquote>
<p>S6. 错误管理(未开始)</p>
<blockquote>
<p><em>S6. Error management</em></p>
</blockquote>
<p>S7. 关键性能指标（KPI）术语表(未开始)</p>
<blockquote>
<p><em>S7. Key Performance Indicator (KPI) glossary</em></p>
</blockquote>
<p>S8. 使用示例(未开始)</p>
<blockquote>
<p><em>S8. Sample Use Cases</em></p>
</blockquote>
<p>S9. 关于控件和元数据的说明(未开始)</p>
<blockquote>
<p><em>S9. Notes on Controls and Metadata</em></p>
</blockquote>
<p>S10. 再处理流程和控制(未开始)</p>
<blockquote>
<p><em>S10. Reprocessing flow and controls</em></p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/11/03/1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Loujuch">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Code Bank">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/11/03/1/" class="post-title-link" itemprop="url">关于GStreamer未关闭Pipeline流输出导致的内存泄露</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2024-11-03 17:30:04 / Modified: 17:43:02" itemprop="dateCreated datePublished" datetime="2024-11-03T17:30:04+08:00">2024-11-03</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="GStreamer引用计数查看方法"><a href="#GStreamer引用计数查看方法" class="headerlink" title="GStreamer引用计数查看方法"></a>GStreamer引用计数查看方法</h2><p>GStreamer提供了<code>GST_OBJECT_REFCOUNT_VALUE</code>宏用于查询引用计数，其要求输入一个<code>GstElement*</code>类型的变量，并返回<code>gint</code>类型的该变量引用计数值。</p>
<p>注意，当输入变量未被分配或已释放（输入变量的引用计数降为0）时，该宏的行为未定义。</p>
<h2 id="Pipeline释放前未设置状态为NULL时可能导致的内存泄露"><a href="#Pipeline释放前未设置状态为NULL时可能导致的内存泄露" class="headerlink" title="Pipeline释放前未设置状态为NULL时可能导致的内存泄露"></a>Pipeline释放前未设置状态为NULL时可能导致的内存泄露</h2><p>当Pipeline释放前未设置状态为NULL时，其具有许多外部的引用计数，此时即使将其<code>unref</code>，也不会使得管道被释放，这将可能导致内存泄露。</p>
<p>使用如下代码进行测试：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gst/gst.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">gboolean <span class="title">stop</span><span class="params">(gpointer data)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">	<span class="built_in">gst_init</span>(&amp;argc, &amp;argv);</span><br><span class="line"></span><br><span class="line">	GstElement* pipeline = <span class="built_in">gst_parse_launch</span>(<span class="string">&quot;playbin uri=https://gstreamer.freedesktop.org/data/media/sintel_trailer-480p.webm&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">	GMainLoop* main_loop = <span class="built_in">g_main_loop_new</span>(<span class="literal">NULL</span>, FALSE);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">g_timeout_add</span>(<span class="number">5000</span>, stop, main_loop);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">g_print</span>(<span class="string">&quot;pipeline ref on a: %d\n&quot;</span>, <span class="built_in">GST_OBJECT_REFCOUNT_VALUE</span>(pipeline));</span><br><span class="line"></span><br><span class="line">	<span class="built_in">gst_element_set_state</span>(pipeline, GST_STATE_PLAYING);</span><br><span class="line">	<span class="built_in">g_print</span>(<span class="string">&quot;pipeline ref on b: %d\n&quot;</span>, <span class="built_in">GST_OBJECT_REFCOUNT_VALUE</span>(pipeline));</span><br><span class="line">	<span class="built_in">g_main_loop_run</span>(main_loop);</span><br><span class="line">	<span class="built_in">g_print</span>(<span class="string">&quot;pipeline ref on c: %d\n&quot;</span>, <span class="built_in">GST_OBJECT_REFCOUNT_VALUE</span>(pipeline));</span><br><span class="line"></span><br><span class="line">	<span class="comment">//gst_element_set_state(pipeline, GST_STATE_NULL);</span></span><br><span class="line">	<span class="built_in">g_print</span>(<span class="string">&quot;pipeline ref on d: %d\n&quot;</span>, <span class="built_in">GST_OBJECT_REFCOUNT_VALUE</span>(pipeline));</span><br><span class="line"></span><br><span class="line">	<span class="built_in">gst_object_unref</span>(pipeline);</span><br><span class="line">	<span class="built_in">g_print</span>(<span class="string">&quot;pipeline ref on e: %d\n&quot;</span>, <span class="built_in">GST_OBJECT_REFCOUNT_VALUE</span>(pipeline));</span><br><span class="line">	<span class="built_in">g_main_loop_unref</span>(main_loop);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">gboolean <span class="title">stop</span><span class="params">(gpointer data)</span> </span>&#123;</span><br><span class="line">	GMainLoop* loop = (GMainLoop*)data;</span><br><span class="line">	<span class="built_in">g_print</span>(<span class="string">&quot;STOP\n&quot;</span>);</span><br><span class="line">	<span class="built_in">g_main_loop_quit</span>(loop);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行后，控制台打印结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pipeline ref on a: 1</span><br><span class="line">pipeline ref on b: 3</span><br><span class="line">STOP</span><br><span class="line">pipeline ref on c: 7</span><br><span class="line">pipeline ref on d: 7</span><br><span class="line">pipeline ref on e: 6</span><br></pre></td></tr></table></figure>

<p>当正确设置状态为NULL时可避免该问题：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pipeline ref on a: <span class="number">1</span></span><br><span class="line">pipeline ref on b: <span class="number">3</span></span><br><span class="line">STOP</span><br><span class="line">pipeline ref on c: <span class="number">7</span></span><br><span class="line">pipeline ref on d: <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>运行后，控制台打印结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pipeline ref on a: 1</span><br><span class="line">pipeline ref on b: 3</span><br><span class="line">STOP</span><br><span class="line">pipeline ref on c: 7</span><br><span class="line">pipeline ref on d: 1</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/11/03/0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Loujuch">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Code Bank">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/11/03/0/" class="post-title-link" itemprop="url">CMake基础模板</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2024-11-03 11:02:44 / Modified: 11:21:34" itemprop="dateCreated datePublished" datetime="2024-11-03T11:02:44+08:00">2024-11-03</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>项目结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">project</span><br><span class="line">├─include</span><br><span class="line">│  └─hello.hpp</span><br><span class="line">├─src</span><br><span class="line">│  ├─lib</span><br><span class="line">│  │  └─hello.cpp</span><br><span class="line">│  └─main.cpp</span><br><span class="line">├─test</span><br><span class="line">│  └─my_test.cpp</span><br><span class="line">└─CMakeLists.txt</span><br></pre></td></tr></table></figure>

<p>使用如下CMake进行编译：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置CMake最低版本</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置项目名</span></span><br><span class="line"><span class="keyword">project</span>(demo)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置编译模式为Debug</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_BUILD_TYPE <span class="string">&quot;Debug&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置需要的CPP标准</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">17</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置输出目录</span></span><br><span class="line"><span class="keyword">set</span>(EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;CMAKE_BINARY_DIR&#125;</span>/bin)</span><br><span class="line"><span class="keyword">set</span>(LIBRARY_OUTPUT_PATH <span class="variable">$&#123;CMAKE_BINARY_DIR&#125;</span>/lib)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开测试</span></span><br><span class="line"><span class="keyword">enable_testing</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加头文件路径</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置库源文件文件</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(<span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/src/lib LIB_SRCS)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加静态库目标</span></span><br><span class="line"><span class="keyword">add_library</span>(hello STATIC <span class="variable">$&#123;LIB_SRCS&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置可执行文件源文件</span></span><br><span class="line"><span class="keyword">file</span>(GLOB MAIN_SRCS <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/src/*.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加可执行文件目标</span></span><br><span class="line"><span class="keyword">add_executable</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> <span class="variable">$&#123;MAIN_SRCS&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接静态库</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> hello)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置测试文件源文件</span></span><br><span class="line"><span class="keyword">file</span>(GLOB TEST_SRCS <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/<span class="keyword">test</span>/*.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为每一个测试文件</span></span><br><span class="line"><span class="keyword">foreach</span>(SRC IN LISTS TEST_SRCS)</span><br><span class="line">    <span class="comment"># 生成测试文件二进制文件名</span></span><br><span class="line">    <span class="keyword">get_filename_component</span>(FILE_NAME <span class="variable">$&#123;SRC&#125;</span> NAME_WE)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 生成测试文件二进制文件</span></span><br><span class="line">    <span class="keyword">add_executable</span>(<span class="variable">$&#123;FILE_NAME&#125;</span> <span class="variable">$&#123;SRC&#125;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 链接静态库</span></span><br><span class="line">    <span class="keyword">target_link_libraries</span>(<span class="variable">$&#123;FILE_NAME&#125;</span> hello)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 添加测试命令</span></span><br><span class="line">    <span class="keyword">add_test</span>(NAME <span class="variable">$&#123;FILE_NAME&#125;</span> <span class="keyword">COMMAND</span> <span class="variable">$&#123;FILE_NAME&#125;</span>)</span><br><span class="line"><span class="keyword">endforeach</span>()</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/11/02/2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Loujuch">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Code Bank">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/11/02/2/" class="post-title-link" itemprop="url">CPP中的线程同步机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2024-11-02 15:22:07 / Modified: 22:02:52" itemprop="dateCreated datePublished" datetime="2024-11-02T15:22:07+08:00">2024-11-02</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="锁机制原理"><a href="#锁机制原理" class="headerlink" title="锁机制原理"></a>锁机制原理</h2><p>锁机制源于信号量，其实现与操作系统息息相关。一般而言，线程存在下图所示的5种状态，其中当线程处于阻塞状态时，不会调度到处理机中运行。</p>
<p><img src="/2024/11/02/2/0.png" alt="线程状态"></p>
<p>信号量机制则为在需互斥线程间共享一个数据，同时提供<code>P</code>、<code>V</code>两种操作，两种操作的行为如下：</p>
<ol>
<li><p><code>P</code>操作：将数据减一，当数据小于零时，将当前线程阻塞。</p>
</li>
<li><p><code>V</code>操作：将数据加一，若此时存在线程阻塞在该信号量时，则唤醒其中一个。</p>
</li>
</ol>
<p>当信号量中使用布尔变量作为共享数据时，则仅允许一个线程进入临界区，实现并发互斥。通常将该信号量称为锁。</p>
<h2 id="CPP中的锁"><a href="#CPP中的锁" class="headerlink" title="CPP中的锁"></a>CPP中的锁</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>在CPP中，根据不同的标准，大致可以分为如下部分：</p>
<p><img src="/2024/11/02/2/1.png"></p>
<p>其中，各标准的含义如下：</p>
<ol>
<li><p>可重入：在一个线程获得目标锁后，再次请求同一把锁时不会阻塞。</p>
</li>
<li><p>限时性：在线程阻塞等待目标锁时，可以设置超时时间，超时时即使未获得目标锁也会解除阻塞。（不是锁的通常分类，但CPP实现中将其区分出来。）</p>
</li>
<li><p>分读写：上锁操作分为读锁和写锁，其中，写锁和互斥锁相同，一旦加上便无法再加上其他写锁和读锁；读锁则可以加上多重，即加上后可以再加上其他读锁，但无法再加上写锁。</p>
</li>
</ol>
<p>根据上述分类标准，CPP中的锁的属性如下：</p>
<table>
<thead>
<tr>
<th>锁类型</th>
<th>可重入</th>
<th>可限时</th>
<th>分读写</th>
</tr>
</thead>
<tbody><tr>
<td>mutex</td>
<td>n</td>
<td>n</td>
<td>n</td>
</tr>
<tr>
<td>timed_mutex</td>
<td>n</td>
<td>y</td>
<td>n</td>
</tr>
<tr>
<td>recursive_mutex</td>
<td>y</td>
<td>n</td>
<td>n</td>
</tr>
<tr>
<td>recursive_timed_mutex</td>
<td>y</td>
<td>y</td>
<td>n</td>
</tr>
<tr>
<td>shared_mutex</td>
<td>n</td>
<td>n</td>
<td>y</td>
</tr>
<tr>
<td>shared_timed_mutex</td>
<td>n</td>
<td>y</td>
<td>y</td>
</tr>
</tbody></table>
<h3 id="公共接口"><a href="#公共接口" class="headerlink" title="公共接口"></a>公共接口</h3><p>所有锁都提供了一些相似的接口，例如，所有的锁只能够调用默认构造函数创建，不能够进行拷贝和移动。其他相似接口如下：</p>
<table>
<thead>
<tr>
<th>接口</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>void lock();</td>
<td>获得目标锁，若无法获得则阻塞当前线程。<br>如果使用的锁可重入，则同一线程可多次调用，否则会在第二次调用时发生死锁。</td>
</tr>
<tr>
<td>bool try_lock() noexcept;</td>
<td>尝试获得锁，若无法立即获得也会立即返回false，否则获得该锁并返回true。</td>
</tr>
<tr>
<td>void unlock();</td>
<td>释放目标锁。</td>
</tr>
</tbody></table>
<p>上述接口所有的锁都具有，因此在锁的RAII机制中具有重要作用。</p>
<h3 id="限时接口"><a href="#限时接口" class="headerlink" title="限时接口"></a>限时接口</h3><p>所有可限时的锁都提供了一些相似的接口，这些相似接口如下：</p>
<table>
<thead>
<tr>
<th>接口</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>template &lt;class Rep, class Period&gt;<br>bool try_lock_for(const std::chrono::duration&lt;Rep, Period&gt;&amp; timeout_duration);</td>
<td>尝试获得目标锁，若未能在timeout_duration的时间内获得该锁则放弃申请，返回false；否则获得该锁，返回true。<br>timeout_duration小于等于timeout_duration.zero()时等价于try_lock。</td>
</tr>
<tr>
<td>template &lt;class Clock, class Duration&gt;<br>bool try_lock_until(const std::chrono::time_point&lt;Clock, Duration&gt;&amp; timeout_time)</td>
<td>尝试获得目标锁，若未能在时间timeout_time前内获得该锁则放弃申请，返回false；否则获得该锁，返回true。<br>timeout_time早于当前时间时等价于try_lock。</td>
</tr>
</tbody></table>
<h3 id="读写接口"><a href="#读写接口" class="headerlink" title="读写接口"></a>读写接口</h3><p>所有分读写的锁使用lock接口作为写锁接口，都提供了一些相似的读锁接口，这些相似接口如下：</p>
<table>
<thead>
<tr>
<th>接口</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>void lock_shared();</td>
<td>获得目标读锁，若无法获得则阻塞当前线程。</td>
</tr>
<tr>
<td>bool try_lock_shared() noexcept;</td>
<td>尝试获得目标读锁，若无法立即获得也会立即返回false，否则获得该锁并返回true。</td>
</tr>
<tr>
<td>void unlock_shared();</td>
<td>释放目标锁。</td>
</tr>
</tbody></table>
<h3 id="读写限时接口"><a href="#读写限时接口" class="headerlink" title="读写限时接口"></a>读写限时接口</h3><p>所有分读写且可限时同时也提供了一些相似的可限时读锁接口，这些相似接口如下：</p>
<table>
<thead>
<tr>
<th>接口</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>template &lt;class Rep, class Period&gt;<br>bool try_lock_shared_for(const std::chrono::duration&lt;Rep, Period&gt;&amp; timeout_duration);</td>
<td>尝试获得目标锁，若未能在timeout_duration的时间内获得该锁则放弃申请，返回false；否则获得该锁，返回true。<br>timeout_duration小于等于timeout_duration.zero()时等价于try_lock_shared。</td>
</tr>
<tr>
<td>template &lt;class Clock, class Duration&gt;<br>bool try_lock_shared_until(const std::chrono::time_point&lt;Clock, Duration&gt;&amp; timeout_time)</td>
<td>尝试获得目标锁，若未能在时间timeout_time前内获得该锁则放弃申请，返回false；否则获得该锁，返回true。<br>timeout_time早于当前时间时等价于try_lock_shared。</td>
</tr>
</tbody></table>
<h2 id="CPP在锁上的RAII机制"><a href="#CPP在锁上的RAII机制" class="headerlink" title="CPP在锁上的RAII机制"></a>CPP在锁上的RAII机制</h2><p>CPP提供了四个类用于实现基于RAII的锁机制，这些类均能够在构造函数中锁上传入的锁，在析构函数中释放对应的锁，有效的解决了因代码改动新加分支等原因导致的锁未释放问题。</p>
<p>同时，还允许通过传入参数进行锁定策略的修改，相应的锁定策略如下：</p>
<table>
<thead>
<tr>
<th>策略参数</th>
<th>策略</th>
</tr>
</thead>
<tbody><tr>
<td>&lt;默认&gt;</td>
<td>调用传入参数的上锁方法，会发生阻塞。</td>
</tr>
<tr>
<td>std::defer_lock</td>
<td>假设当前未获得锁，之后会手动申请。</td>
</tr>
<tr>
<td>std::try_to_lock</td>
<td>尝试获取锁，但有可能失败，这不会阻塞。</td>
</tr>
<tr>
<td>std::adopt_lock</td>
<td>假设当前已经获取了锁。</td>
</tr>
<tr>
<td>std::chrono::duration</td>
<td>调用传入参数的lock_for方法，会发生阻塞。</td>
</tr>
<tr>
<td>std::chrono::time_point</td>
<td>调用传入参数的lock_until方法，会发生阻塞。</td>
</tr>
</tbody></table>
<p>实现RAII机制的类的类型和特点如下：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>特点</th>
<th>支持策略</th>
</tr>
</thead>
<tbody><tr>
<td>lock_guard</td>
<td>不可移动，不可拷贝</td>
<td>adopt_lock</td>
</tr>
<tr>
<td>scoped_lock</td>
<td>不可移动，不可拷贝。<br>能够一次申请多把锁。</td>
<td>adopt_lock</td>
</tr>
<tr>
<td>unique_lock</td>
<td>可移动，不可拷贝</td>
<td>defer_lock、try_to_lock、adopt_lock、duration、time_point</td>
</tr>
<tr>
<td>shared_lock</td>
<td>可移动，不可拷贝。<br>申请的是读锁。</td>
<td>defer_lock、try_to_lock、adopt_lock、duration、time_point</td>
</tr>
</tbody></table>
<p>同时，<code>unique_lock</code>和<code>shared_lock</code>还提供了如下接口：</p>
<table>
<thead>
<tr>
<th>接口</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>void lock();</td>
<td>获得目标锁，若无法获得则阻塞当前线程。<br>如果使用的锁可重入，则同一线程可多次调用，否则会在第二次调用时发生死锁。</td>
</tr>
<tr>
<td>bool try_lock() noexcept;</td>
<td>尝试获得锁，若无法立即获得也会立即返回false，否则获得该锁并返回true。</td>
</tr>
<tr>
<td>template &lt;class Rep, class Period&gt;<br>bool try_lock_for(const std::chrono::duration&lt;Rep, Period&gt;&amp; timeout_duration);</td>
<td>尝试获得目标锁，若未能在timeout_duration的时间内获得该锁则放弃申请，返回false；否则获得该锁，返回true。<br>timeout_duration小于等于timeout_duration.zero()时等价于try_lock。</td>
</tr>
<tr>
<td>template &lt;class Clock, class Duration&gt;<br>bool try_lock_until(const std::chrono::time_point&lt;Clock, Duration&gt;&amp; timeout_time)</td>
<td>尝试获得目标锁，若未能在时间timeout_time前内获得该锁则放弃申请，返回false；否则获得该锁，返回true。<br>timeout_time早于当前时间时等价于try_lock。</td>
</tr>
<tr>
<td>void unlock();</td>
<td>释放目标锁。</td>
</tr>
<tr>
<td>mutex_type* release() noexcept;</td>
<td>未释放目标锁的放弃对目标锁的控制权。</td>
</tr>
<tr>
<td>bool owns_lock() const noexcept;</td>
<td>返回其是否持有已锁定的锁。</td>
</tr>
<tr>
<td>explicit operator bool() const noexcept;</td>
<td>隐式类型转换函数，相当于调用owns_lock。</td>
</tr>
</tbody></table>
<h2 id="CPP提供的通用锁定方法"><a href="#CPP提供的通用锁定方法" class="headerlink" title="CPP提供的通用锁定方法"></a>CPP提供的通用锁定方法</h2><p>CPP提供以下能够获取锁的方法：</p>
<table>
<thead>
<tr>
<th>接口</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>template &lt;class Lockable1, class Lockable2, class… LockableN&gt;<br>void lock(Lockable1&amp; lock1, Lockable2&amp; lock2, LockableN&amp;… lockn);</td>
<td>使用死锁避免算法尝试获得多把锁。</td>
</tr>
<tr>
<td>template &lt;class Lockable1, class Lockable2, class… LockableN&gt;<br>int try_lock(Lockable1&amp; lock1, Lockable2&amp; lock2, LockableN&amp;… lockn);</td>
<td>从头开始锁定传入的锁，如果存在失败的，则立即返回失败锁在传入参数的以0为底的下标；若都获取成功，返回-1。</td>
</tr>
</tbody></table>
<h2 id="CPP条件变量"><a href="#CPP条件变量" class="headerlink" title="CPP条件变量"></a>CPP条件变量</h2><p>条件变量将会是CPP线程同步的重要机制，其原理和信号量类似，是通过线程的阻塞和唤醒实现的。</p>
<p>CPP中提供了<code>condition_variable</code>和<code>condition_variable_any</code>作为条件变量，两者完全一致，唯一的区别是<code>condition_variable</code>wait时只能使用<code>std::unique&lt;std::mutex&gt;</code>作为参数而<code>condition_variable_any</code>wait时能够使用任意锁作为参数。</p>
<p>两者提供了相似的接口，具体如下：</p>
<table>
<thead>
<tr>
<th>接口</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>void notify_one() noexcept;</td>
<td>唤醒正在等待该条件变量的一个线程。</td>
</tr>
<tr>
<td>void notify_all() noexcept;</td>
<td>唤醒正在等待该条件变量的所有线程，即使被唤醒线程因为锁竞争等原因再次阻塞也不会再次等待条件变量信号。</td>
</tr>
<tr>
<td>void wait(Lock&amp; lock);</td>
<td>等待条件变量唤醒信号，要求lock已经由当前线程持有。</td>
</tr>
<tr>
<td>void wait(Lock&amp; lock, Predicate pred);</td>
<td>相当于while(!pred()) { wait(lock); }。</td>
</tr>
<tr>
<td>std::cv_status wait_until(Lock&amp; lock, const std::chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time);</td>
<td>等待条件变量唤醒信号或到达指定时间，要求lock已经由当前线程持有。</td>
</tr>
<tr>
<td>bool wait_until(Lock&amp; lock, const std::chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time， Predicate pred);</td>
<td>相当于while(!pred) { if(wait_until(lock, abs_time) &#x3D;&#x3D; std::cv_status::timeout) { return pred(); } } return true;。</td>
</tr>
<tr>
<td>std::cv_status wait_for(Lock&amp; lock, const std::chrono::duration&lt;Rep, Period&gt;&amp; rel_time);</td>
<td>相当于wait_until(lock, std::chrono::steady_clock::now() + rel_time)。</td>
</tr>
<tr>
<td>bool wait_for(Lock&amp; lock, const std::chrono::duration&lt;Rep, Period&gt;&amp; rel_time， Predicate pred);</td>
<td>相当于wait_until(lock, std::chrono::steady_clock::now() + rel_time, std::move(pred));。</td>
</tr>
</tbody></table>
<p>其中，<code>std::cv_status</code>包含以下类型：</p>
<ol>
<li><p>std::cv_status::no_timeout：未超时</p>
</li>
<li><p>std::cv_status::timeout：超时</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/11/02/1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Loujuch">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Code Bank">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/11/02/1/" class="post-title-link" itemprop="url">gdb基本调试命令</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2024-11-02 12:48:42 / Modified: 13:56:51" itemprop="dateCreated datePublished" datetime="2024-11-02T12:48:42+08:00">2024-11-02</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>gdb是Linux下常用的命令行调试器，在Debian下使用如下命令安装：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install gdb -y</span><br></pre></td></tr></table></figure>

<p>可以使用如下三种方式运行gdb程序，对目标二进制文件进行调试：</p>
<ol>
<li><p><code>gdb &lt;file_name&gt;</code>：运行目标文件，从头开始调试。</p>
</li>
<li><p><code>gdb &lt;file_name&gt; &lt;core_name&gt;</code>：根据core文件对目标文件进行调试。</p>
</li>
<li><p><code>gdb &lt;file_name&gt; &lt;pid&gt;</code>：远程调试，调试目标文件的对应正在运行的进程。</p>
</li>
</ol>
<p>在进入调试界面后，可以使用一些调试命令以更好地对程序进行调试，其主要分为以下几类：</p>
<ol>
<li><p>流程控制：按照使用者想法运行程序。</p>
</li>
<li><p>断点管理：管理断点，使得程序在运行时满足某种条件时能够暂停。</p>
</li>
<li><p>信息输出：输出使用者希望输出的信息。</p>
</li>
<li><p>环境设置：动态改变程序内部或外部的执行环境。</p>
</li>
</ol>
<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><table>
<thead>
<tr>
<th>指令</th>
<th>缩写</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>run [&lt;arg&gt;]</td>
<td>r</td>
<td>运行未运行的程序</td>
</tr>
<tr>
<td>cotinue [&lt;ignore_num&gt;]</td>
<td>c</td>
<td>在程序被中断后继续运行</td>
</tr>
<tr>
<td>step [&lt;inst_num&gt;]</td>
<td>s</td>
<td>执行inst_num条指令，遇到函数时进入函数（如果该函数有调试信息）</td>
</tr>
<tr>
<td>next [&lt;inst_num&gt;]</td>
<td>n</td>
<td>执行inst_num条指令，遇到函数视为一条指令，不会进入函数内部</td>
</tr>
<tr>
<td>finish</td>
<td>fin</td>
<td>执行直到当前函数返回，并打印返回值</td>
</tr>
<tr>
<td>until [&lt;target&gt;]</td>
<td>u</td>
<td>执行完当前循环，若目标位置被指定则执行到目标位置，除非函数返回</td>
</tr>
</tbody></table>
<h2 id="断点管理"><a href="#断点管理" class="headerlink" title="断点管理"></a>断点管理</h2><h3 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h3><p>断点用于观察控制流的运行位置，当控制流运行到断点时停止程序。</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>缩写</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>break [&lt;pos&gt; [if &lt;cond&gt;]]</td>
<td>b</td>
<td>设置断点在pos，如设置了cond，则当条件未达成时不触发断点</td>
</tr>
</tbody></table>
<p>其中<code>pos</code>的设置如下：</p>
<ol>
<li><p><code>&lt;file_name&gt;:&lt;line_num&gt;</code>：在进入指定文件对应行号的指令前设置断点。</p>
</li>
<li><p><code>&lt;file_name&gt;:&lt;func_name&gt;</code>：在进入指定文件对应函数的指令前设置断点。</p>
</li>
<li><p><code>*&lt;inst_addr&gt;</code>：在进入指定地址对应的指令前设置断点。</p>
</li>
</ol>
<h3 id="观察点"><a href="#观察点" class="headerlink" title="观察点"></a>观察点</h3><p>观察点用于观察目标表达式的值是否发生变化。目标表达式的值发生变化时停止程序。</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>缩写</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>watch [&lt;expr&gt; [if &lt;cond&gt;]]</td>
<td>w</td>
<td>若目标表达式的值发生变化，则停止程序</td>
</tr>
<tr>
<td>rwatch [&lt;expr&gt; [if &lt;cond&gt;]]</td>
<td>rw</td>
<td>若目标表达式被读，则停止程序</td>
</tr>
<tr>
<td>awatch [&lt;expr&gt; [if &lt;cond&gt;]]</td>
<td>aw</td>
<td>若目标表达式被读或写，则停止程序</td>
</tr>
</tbody></table>
<h3 id="捕捉点"><a href="#捕捉点" class="headerlink" title="捕捉点"></a>捕捉点</h3><p>捕获点用于捕获当前程序发生的行为，当指定行为发生时停止程序。</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>缩写</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>catch &lt;event&gt;</td>
<td>cat</td>
<td>发生event对应事件时停止程序</td>
</tr>
<tr>
<td>tcatch &lt;event&gt;</td>
<td>tc</td>
<td>发生event对应事件时停止程序，只会触发一次</td>
</tr>
</tbody></table>
<p>其中event如下：</p>
<table>
<thead>
<tr>
<th>event</th>
<th>事件</th>
</tr>
</thead>
<tbody><tr>
<td>throw</td>
<td>C++抛出异常时</td>
</tr>
<tr>
<td>catch</td>
<td>C++捕获异常时</td>
</tr>
<tr>
<td>exec</td>
<td>调用exec时，只在HP-UX下有用（修改进程运行程序）</td>
</tr>
<tr>
<td>fork</td>
<td>调用fork时，只在HP-UX下有用（创建进程）</td>
</tr>
<tr>
<td>vfork</td>
<td>调用vfork时，只在HP-UX下有用（创建进程）</td>
</tr>
<tr>
<td>load</td>
<td>调用load时，只在HP-UX下有用（加载动态库）</td>
</tr>
<tr>
<td>unload</td>
<td>调用unload时，只在HP-UX下有用（卸载动态库）</td>
</tr>
</tbody></table>
<h3 id="停止点控制"><a href="#停止点控制" class="headerlink" title="停止点控制"></a>停止点控制</h3><table>
<thead>
<tr>
<th>指令</th>
<th>缩写</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>clear [&lt;pos_range&gt;]</td>
<td>cl</td>
<td>删除指定位置范围的停止点</td>
</tr>
<tr>
<td>delete [&lt;id_list&gt;]</td>
<td>del</td>
<td>根据停止点ID删除对应停止点</td>
</tr>
<tr>
<td>disable [&lt;id_list&gt;]</td>
<td>dis</td>
<td>根据停止点ID停用对应停止点</td>
</tr>
<tr>
<td>enable [&lt;id_list&gt;]</td>
<td>en</td>
<td>根据停止点ID启用对应停止点</td>
</tr>
<tr>
<td>condition &lt;id&gt; &lt;cond&gt;</td>
<td>cond</td>
<td>给对应停止点添加触发条件</td>
</tr>
<tr>
<td>ignore &lt;id&gt; &lt;ign_num&gt;</td>
<td>ig</td>
<td>忽略对应停止点指定次数</td>
</tr>
</tbody></table>
<h2 id="信息输出"><a href="#信息输出" class="headerlink" title="信息输出"></a>信息输出</h2><table>
<thead>
<tr>
<th>指令</th>
<th>缩写</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>print &lt;expr&gt;</td>
<td>p</td>
<td>打印指定变量或表达式的值</td>
</tr>
<tr>
<td>display &lt;expr&gt;</td>
<td>disp</td>
<td>追踪目标表达式的值，每次停止时打印追踪的表达式值</td>
</tr>
<tr>
<td>info &lt;sign&gt;</td>
<td>i</td>
<td>打印gdb内部信息</td>
</tr>
<tr>
<td>x &lt;addr&gt;</td>
<td></td>
<td>打印内存信息</td>
</tr>
</tbody></table>
<h2 id="环境设置"><a href="#环境设置" class="headerlink" title="环境设置"></a>环境设置</h2><table>
<thead>
<tr>
<th>指令</th>
<th>缩写</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>set &lt;context&gt;</td>
<td></td>
<td>设置环境变量或gdb状态等</td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/11/02/0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Loujuch">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Code Bank">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/11/02/0/" class="post-title-link" itemprop="url">Win 10 配置CPP开发环境</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2024-11-02 10:21:54 / Modified: 12:44:17" itemprop="dateCreated datePublished" datetime="2024-11-02T10:21:54+08:00">2024-11-02</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="安装Chocolatey"><a href="#安装Chocolatey" class="headerlink" title="安装Chocolatey"></a>安装Chocolatey</h2><p>使用Chocolatey进行包管理，其安装方法详见<a target="_blank" rel="noopener" href="https://chocolatey.org/install#individual">chocolatey安装</a>。</p>
<ol>
<li><p>使用管理员权限运行<code>powershell</code>。</p>
</li>
<li><p>执行如下命令。</p>
 <figure class="highlight ps1"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Set-ExecutionPolicy</span> Bypass <span class="literal">-Scope</span> <span class="keyword">Process</span> <span class="literal">-Force</span>; [<span class="type">System.Net.ServicePointManager</span>]::SecurityProtocol = [<span class="type">System.Net.ServicePointManager</span>]::SecurityProtocol <span class="operator">-bor</span> <span class="number">3072</span>; <span class="built_in">iex</span> ((<span class="built_in">New-Object</span> System.Net.WebClient).DownloadString(<span class="string">&#x27;https://community.chocolatey.org/install.ps1&#x27;</span>))</span><br></pre></td></tr></table></figure>
</li>
<li><p>输入<code>choco -?</code>验证是否安装成功。</p>
</li>
</ol>
<h2 id="安装依赖包"><a href="#安装依赖包" class="headerlink" title="安装依赖包"></a>安装依赖包</h2><ol>
<li><p>使用管理员权限运行<code>powershell</code>。</p>
</li>
<li><p>执行如下命令。</p>
 <figure class="highlight ps1"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">choco install <span class="literal">--yes</span> mingw make cmake git</span><br></pre></td></tr></table></figure>


</li>
<li><p>执行如下命令验证是否安装成功:</p>
 <figure class="highlight ps1"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gcc <span class="literal">--version</span></span><br><span class="line">g++ <span class="literal">--version</span></span><br><span class="line">make <span class="literal">--version</span></span><br><span class="line">cmake <span class="literal">--version</span></span><br><span class="line">git <span class="literal">--version</span></span><br></pre></td></tr></table></figure></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/10/27/1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Loujuch">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Code Bank">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/10/27/1/" class="post-title-link" itemprop="url">C++ Future机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-10-27 22:07:27" itemprop="dateCreated datePublished" datetime="2024-10-27T22:07:27+08:00">2024-10-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-10-30 23:01:53" itemprop="dateModified" datetime="2024-10-30T23:01:53+08:00">2024-10-30</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Future机制"><a href="#Future机制" class="headerlink" title="Future机制"></a>Future机制</h2><p>CPP Future机制用于获取异步任务的异常和返回结果，尽管也可以通过传入的指针或引用返回结果，但其需要引入外部变量，较为麻烦，且难以捕获异常。</p>
<p>Future机制由promise和future配合实现异步返回，promise用于在异步任务中设置返回结果，future用于获取在原线程中获取异步任务返回结果，两者间通过共享状态（shared state）进行通信。三者关系如下图：</p>
<p><img src="/2024/10/27/1/0.png"></p>
<h2 id="CPP中的promise和future"><a href="#CPP中的promise和future" class="headerlink" title="CPP中的promise和future"></a>CPP中的promise和future</h2><p>CPP提供了<code>std::promise</code>充当Future机制中的promise，<code>std::future</code>和<code>std::shared_future</code>充当Future机制中的future，两者共同作用解决完成异步数据传输。</p>
<h3 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h3><p>CPP提供了<code>std::promise</code>充当Future机制中的promise，<code>std::promise</code>只能进行默认构造和移动，无法进行拷贝。</p>
<p><code>std::promise</code>提供如下接口进行数据传输：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>std::future&lt;R&gt; get_future();</td>
<td>返回一个与promise关联相同共享状态的<code>std::future</code>对象</td>
</tr>
<tr>
<td>void set_value(const R&amp; value);<br>void set_value(R&amp;&amp; value);</td>
<td>立即设置promise的共享状态的值</td>
</tr>
<tr>
<td>void set_exception( std::exception_ptr p );</td>
<td>立即设置promise的共享状态捕获的异常</td>
</tr>
<tr>
<td>void set_value_at_thread_exit(const R &amp;value);<br>void set_value_at_thread_exit(R &amp;&amp;value);</td>
<td>在线程结束后设置promise的共享状态的值</td>
</tr>
<tr>
<td>void set_exception_at_thread_exit(std::exception_ptr p);</td>
<td>在线程结束后设置promise的共享状态捕获的异常</td>
</tr>
</tbody></table>
<p>在使用<code>std::promise</code>时有以下注意事项：</p>
<ol>
<li><p><code>std::promise</code>是一次性的，一旦设置了相应的值，再次调用设值函数将会抛出异常。</p>
</li>
<li><p><code>std::promise</code>的任何方法都不会断开与共享状态的连接，因此可以多次调用<code>get_future</code>。</p>
</li>
<li><p><code>set_*</code>和<code>set_*_at_thread_exit</code>之间的区别在于，<code>set_*</code>将会使得与该对象内部的共享状态相关联的<code>future</code>将能够立即获得值；<code>set_*_at_thread_exit</code>将会使得与该对象内部的共享状态相关联的<code>future</code>将在异步线程退出后才获得值。</p>
</li>
</ol>
<h3 id="future"><a href="#future" class="headerlink" title="future"></a>future</h3><p>CPP提供了<code>std::future</code>和<code>std::shared_future</code>充当Future机制中的future，两者提供了一些相同的接口用于实现异步线程数据传输：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>T get();<br>T&amp; get();</td>
<td>获取共享状态的值或捕获的异常。<br>若此时共享状态未被设置值或捕获异常则进行阻塞等待</td>
</tr>
<tr>
<td>bool valid() const noexcept;</td>
<td>当future绑定共享状态时返回true，否则返回false</td>
</tr>
<tr>
<td>void wait() const;</td>
<td>阻塞等待，直到共享状态被设置值或捕获异常</td>
</tr>
<tr>
<td>template &lt;class Rep, class Period&gt;<br>std::future_status wait_for(const std::chrono::duration&lt;Rep,Period&gt;&amp; timeout_duration) const;</td>
<td>阻塞等待，直到共享状态被设置值或捕获异常，或者线程已被阻塞了timeout_duration时间</td>
</tr>
<tr>
<td>template &lt;class Clock, class Duration&gt;<br>std::future_status wait_until(const std::chrono::time_point&lt;Clock,Duration&gt;&amp; timeout_time) const;</td>
<td>阻塞等待，直到共享状态被设置值或捕获异常，或者线程被阻塞直到timeout_time</td>
</tr>
</tbody></table>
<p>尽管<code>std::future</code>和<code>std::shared_future</code>提供了相似的异步线程数据传输接口，但二者具有以下区别：</p>
<table>
<thead>
<tr>
<th>std::future</th>
<th>std::shared_future</th>
</tr>
</thead>
<tbody><tr>
<td>只能进行默认构造或移动，不能进行拷贝</td>
<td>能进行默认构造、拷贝和移动</td>
</tr>
<tr>
<td>无法进行安全的线程共享</td>
<td>同一个实例无法安全的进行线程共享<br>拷贝生成的示例能够在多线程环境下安全的对共享状态的值进行赋值</td>
</tr>
<tr>
<td>调用<code>get</code>函数后将与相应的共享状态切断联系，因此只能调用一次</td>
<td>调用<code>get</code>函数后不与相应的共享状态切断联系，因此能够调用多次</td>
</tr>
<tr>
<td>能够通过<code>std::shared_funtre&lt;T&gt; share() noexcept;</code>转化为<code>std::shared_future</code><br>调用该方法后将与相应的共享状态切断联系</td>
<td>能够接收<code>std::funtre&lt;T&gt; &amp;&amp;</code>进行构造<br>调用该方法后输入的<code>std::funtre&lt;T&gt; &amp;&amp;</code>将与相应的共享状态切断联系</td>
</tr>
</tbody></table>
<p>对于<code>wait_for</code>和<code>wait_until</code>，可以通过返回值判断其返回时的状态，其返回值可能为：</p>
<ol>
<li><p><code>std::future_status::ready</code>：共享状态就绪。</p>
</li>
<li><p><code>std::future_status::timeout</code>：等待超时。</p>
</li>
<li><p><code>std::future_status::deferred</code>：共享状态关联的是一个<code>deferred</code>的函数，只有在调用<code>get</code>时才能赋值（详见<code>std::async</code>）。</p>
</li>
</ol>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><p>下面给出一个简单的代码示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::promise&lt;<span class="type">int</span>&gt; pro;</span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; fut = pro.<span class="built_in">get_future</span>();</span><br><span class="line">    std::cout &lt;&lt; fut.<span class="built_in">valid</span>() &lt;&lt; std::endl;</span><br><span class="line">    pro.<span class="built_in">set_value</span>(<span class="number">1024</span>);</span><br><span class="line">    std::cout &lt;&lt; fut.<span class="built_in">valid</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; fut.<span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; fut.<span class="built_in">valid</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_execption</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::promise&lt;<span class="type">int</span>&gt; pro;</span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; fut = pro.<span class="built_in">get_future</span>();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Example&quot;</span>);</span><br><span class="line">    &#125; <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Catch&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            pro.<span class="built_in">set_exception</span>(std::<span class="built_in">current_exception</span>());</span><br><span class="line">        &#125; <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Error&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    <span class="keyword">try</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; fut.<span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception &amp;e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Throw: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test_value</span>();</span><br><span class="line">    <span class="built_in">test_execption</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行后打印：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">1</span><br><span class="line">1024</span><br><span class="line">0</span><br><span class="line">Catch</span><br><span class="line">Throw: Example</span><br></pre></td></tr></table></figure>

<h2 id="CPP异步任务"><a href="#CPP异步任务" class="headerlink" title="CPP异步任务"></a>CPP异步任务</h2><p>为了便于创建和使用异步任务而无需手动管理<code>promise</code>和<code>future</code>，CPP提供了<code>std::packaged_task</code>和<code>std::async</code>用于构建异步任务。</p>
<h3 id="packaged-task"><a href="#packaged-task" class="headerlink" title="packaged_task"></a>packaged_task</h3><p>CPP提供了<code>std::packaged_task</code>类用于方便的将已有函数打包为异步可调用对象，其提供了默认构造函数、基于仿函数的构造函数、移动构造函数和移动赋值函数来设置相应的值，并提供以下方法：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>bool valid() const noexcept;</td>
<td>返回packaged_task内部是否有有效的仿函数</td>
</tr>
<tr>
<td>std::future<R> get_future();</td>
<td>返回一个与packaged_task关联的future对象<br>可以多次调用返回多个关联相同共享状态的future</td>
</tr>
<tr>
<td>void operator()(ArgTypes… args);</td>
<td>使用args作为参数调用packaged_task内的仿函数，并立即将调用结果赋值到共享状态中</td>
</tr>
<tr>
<td>void make_ready_at_thread_exit(ArgTypes… args);</td>
<td>使用args作为参数调用packaged_task内的仿函数，调用结果将在异步线程结束后赋值到共享状态中</td>
</tr>
<tr>
<td>void reset();</td>
<td>重置内部状态，其所关联的future全部失效，但具有的仿函数不变</td>
</tr>
</tbody></table>
<p>下面是一个简单的使用示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">func</span><span class="params">(<span class="type">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">to_string</span>(s | INT32_MIN);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">std::packaged_task&lt;<span class="title">std::string</span><span class="params">(<span class="type">int</span>)</span>&gt; <span class="title">ptask</span><span class="params">(func)</span></span>;</span><br><span class="line">    std::future&lt;std::string&gt; f = ptask.<span class="built_in">get_future</span>();</span><br><span class="line">    <span class="function">std::thread <span class="title">th</span><span class="params">(std::move(ptask), INT32_MAX)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; f.<span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line">    th.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行后将获得如下结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1</span><br></pre></td></tr></table></figure>

<h3 id="async"><a href="#async" class="headerlink" title="async"></a>async</h3><p>CPP提供了<code>std::async</code>函数方便的创建并运行异步任务，其函数签名如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">F</span>, <span class="keyword">class</span> ... Args&gt;</span><br><span class="line"><span class="function">std::future&lt;...&gt; <span class="title">async</span><span class="params">(F&amp;&amp; f, Args&amp;&amp; ... args)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">F</span>, <span class="keyword">class</span> ... Args&gt;</span><br><span class="line"><span class="function">std::future&lt;...&gt; <span class="title">async</span><span class="params">(std::launch policy, F&amp;&amp; f, Args&amp;&amp; ... args)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中，不带<code>policy</code>参数的版本相当于向带参数版本中传入<code>policy</code>参数<code>std::launch::async | std::launch::deferred</code>。</p>
<p>该函数能够创建一个异步任务，其有两种执行方式：</p>
<ol>
<li><p>异步调用，在另一个线程（新线程或线程池中的线程）中运行异步任务，并设置共享状态传递执行结果。</p>
</li>
<li><p>延迟调用，当future调用<code>wait</code>或<code>get</code>时在被阻塞线程运行异步任务并通过设置共享状态传递执行结果，调用<code>wait_for</code>或<code>wait_until</code>时返回<code>std::future_status::deferred</code>。</p>
</li>
</ol>
<p>可以通过<code>policy</code>参数设置开启的异步任务的执行方式：</p>
<ol>
<li><p>同时设置<code>std::launch::async</code>和<code>std::launch::deferred</code>：由标准库和当前系统状态进行决定，一般来说，当系统线程数量达到上限或系统线程超发（就绪线程数大于CPU并发线程数）时会采用延迟调用，否则会采用异步调用。</p>
</li>
<li><p>仅设置<code>std::launch::async</code>：总是进行异步调用。</p>
</li>
<li><p>仅设置<code>std::launch::deferred</code>：总是进行延迟调用。</p>
</li>
<li><p>未设置<code>std::launch::async</code>和<code>std::launch::deferred</code>：行为未定义，</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Loujuch</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">33</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Loujuch</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
